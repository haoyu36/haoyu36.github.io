<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>mysql基础 | haoyu blog</title><meta name=keywords content="mysql"><meta name=description content="基础 [TOC]
一：数据库 1.1 MySQL 引擎 存储引擎指表的类型，决定了表在计算机中的存储方式。MySQL 默认存储引擎为 InnoDB，支持事务、原子操作、回滚等等。常见的存储引擎 InnoDB 和 MyISAM。如果系统读多写少，并发不高，对原子性要求低，选择 MyISAM；如果系统读少写多，尤其是并发写入高的时候，首选 InnoDB"><meta name=author content><link rel=canonical href=http://120.79.76.172:8381/post/mysql%E5%9F%BA%E7%A1%80/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://120.79.76.172:8381/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://120.79.76.172:8381/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://120.79.76.172:8381/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://120.79.76.172:8381/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://120.79.76.172:8381/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="mysql基础"><meta property="og:description" content="基础 [TOC]
一：数据库 1.1 MySQL 引擎 存储引擎指表的类型，决定了表在计算机中的存储方式。MySQL 默认存储引擎为 InnoDB，支持事务、原子操作、回滚等等。常见的存储引擎 InnoDB 和 MyISAM。如果系统读多写少，并发不高，对原子性要求低，选择 MyISAM；如果系统读少写多，尤其是并发写入高的时候，首选 InnoDB"><meta property="og:type" content="article"><meta property="og:url" content="http://120.79.76.172:8381/post/mysql%E5%9F%BA%E7%A1%80/"><meta property="article:section" content="post"><meta property="article:published_time" content="2021-10-01T15:40:18+00:00"><meta property="article:modified_time" content="2021-10-01T15:40:18+00:00"><meta property="og:site_name" content="haoyu blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="mysql基础"><meta name=twitter:description content="基础 [TOC]
一：数据库 1.1 MySQL 引擎 存储引擎指表的类型，决定了表在计算机中的存储方式。MySQL 默认存储引擎为 InnoDB，支持事务、原子操作、回滚等等。常见的存储引擎 InnoDB 和 MyISAM。如果系统读多写少，并发不高，对原子性要求低，选择 MyISAM；如果系统读少写多，尤其是并发写入高的时候，首选 InnoDB"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"http://120.79.76.172:8381/post/"},{"@type":"ListItem","position":3,"name":"mysql基础","item":"http://120.79.76.172:8381/post/mysql%E5%9F%BA%E7%A1%80/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"mysql基础","name":"mysql基础","description":"基础 [TOC]\n一：数据库 1.1 MySQL 引擎 存储引擎指表的类型，决定了表在计算机中的存储方式。MySQL 默认存储引擎为 InnoDB，支持事务、原子操作、回滚等等。常见的存储引擎 InnoDB 和 MyISAM。如果系统读多写少，并发不高，对原子性要求低，选择 MyISAM；如果系统读少写多，尤其是并发写入高的时候，首选 InnoDB","keywords":["mysql"],"articleBody":"基础 [TOC]\n一：数据库 1.1 MySQL 引擎 存储引擎指表的类型，决定了表在计算机中的存储方式。MySQL 默认存储引擎为 InnoDB，支持事务、原子操作、回滚等等。常见的存储引擎 InnoDB 和 MyISAM。如果系统读多写少，并发不高，对原子性要求低，选择 MyISAM；如果系统读少写多，尤其是并发写入高的时候，首选 InnoDB\n引擎 InnoDB MyISAM 事务 支持 不支持 锁 支持到行级锁 只支持表级锁 MVCC 支持 不支持 外键 支持 不支持 全文索引 不支持 支持 1.2 MySQL 8.0新特性 窗口函数：可以对一组查询行执行聚合，为每行生成一个结果 递归 CTE：支持用户在不使用游标的情况下，执行引用其自身名称的子查询 默认字符集支持从 Latin1 转变为 utf8mb4，其中，utf8mb4 支持每个字符最多使用四个字节 隐藏索引：允许从查询优化器中排除索引 改进对 JSON 的支持，增加了 JSON_EXTRACT 函数，可以根据路径查询参数从 json 字段中提取数据 提供了灵活的角色支持，包括创建、删除和授予角色功能 二：主键与外键 2.1 主键 确定一条记录的唯一标识 可以被外键有效引用 一张表只能有一个主键，其值不能重复，不能为空 如果主键为多列，则其组合必须唯一 主键设计原则:\n主键应当是对用户没有意义的 一般将自增列设置为主键 永远不要更新主键 主键应该为单列，以提高连接和筛选操作的效率 主键不应包含动态变化的数据，如时间戳、创建时间列、修改时间列等 2.2 外键 如果一张表中有一个非主键的字段指向了别一张表中的主键，就将该字段叫做外键\n表的外键是另一表的主键 一张表可以有多个外键，其值可以重复，可以为空 外键名字不能重复 外键的列类型必须与父表的主键类型应一致 外键设计原则:\n外键用来和其他表建立联系（约束），实现表与表之间数据的一致性和更新 创建外键时自动将外键所在列设置索引列 表储存引擎必须是 innodb，否则创建的外键无约束效果 将已经存在数据的字段设为外键，必须保证字段中的数据与父表的主键数据对应 子表(外键所在的表)在进行写操作的时候，如果外键字段在父表中找不到对应的匹配，操作失败 父表的主键字段进行删和改时，如果对应的主键在子表中被引用，操作失败 创建外键时可选择不同的约束模式 外键的性能问题:\n数据库要维护外键的内部管理 对外键字段进行增删改查会消耗资源去检查 三：高级 3.1 视图 视图是虚拟（临时）的表，与包含数据的表不一样，只能用做查询 视图只在执行时才动态检索数据 视图可以简化复杂的 sql 操作，隐藏具体的细节，保护数据 视图创建后，可以使用与表相同的方式利使用 视图不能被索引，也不能有关联的触发器或默认值 视图和表的区别：\n视图是已经编译好的 sql 语句，是基于 sql 语句的结果集的可视化的表，而表不是 视图是窗口，表是内容 视图没有实际的物理记录，而表有 视图是虚表，表是实表 视图的建立和删除只影响视图本身，不影响对应的表 3.2 存储过程 存储过程是一个预编译的SQL语句，只需创建一次，以后在该程序中就可以调用多次。使用存储过程比单纯 SQL 语句执行要快\n优点：\n存储过程是预编译过的，执行效率高 存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯 安全性高，执行存储过程需要有一定权限的用户 存储过程可以重复使用，可减少数据库开发人员的工作量 缺点：移植性差\n3.3 游标 游标是通过 select 查询出来的结果集，通过游标可以从结果集中获得指定行（第一行、下一行、前10行）\n游标一般用于交互式应用，需要逐条处理数据的时候，游标显得十分重要\n3.4 触发器 触发器是一中特殊的存储过程，主要是通过事件来触发而被执行的\n四：其他 4.1 自增 在每个行添加到表中时，MySQL 可以自动地为每个行分配下一个可用编号\n自增列在插入数据时默认自动添加 表中只能有一个自增列 自增列类型为数字 自增列必须是索引 4.2 内连表、左连表、右连表 内连接：两个表都存在匹配时，才会返回匹配行。第一个表中的每一行与第二个表中的每一行数据配对 左连接：是根据某个条件以及左边的表连接数据，右边的表没有数据的话则为 null 右连接：根据某个条件以及右边的表连接数据，左边的表没有数据的话则为 null 4.3 drop, delete 与 truncate drop 直接删掉表，并将表所占用的空间全释放掉 truncate 删除表中数据，再插入时自增长 id 又从 1 开始。truncate 可以理解为 drop + create。当表被 truncate 后，表和索引所占用的空间会恢复到初始大小 delete 删除表中数据，可以加 where 子句。delete 命令只是把记录的位置标记为了“可复用”，但磁盘文件的大小是不会变的。即通过 delete 命令是不能回收表空间的 4.4 sql 语句安全性 防止 sql 注入，对特殊字符进行转义，过滤或者使用预编译的 sql 语句绑定变量 最小权限原则，特别是不要用 root 账户，为不同的类型的动作或者组建使用不同的账户 当 sql 运行出错时，不要把数据库返回的错误信息全部显示给用户，以防止泄漏服务器和数据库相关信息 4.5 如何应对数据的高并发，大量的数据计算 合理设计表结构、索引 使用存储过程来处理复杂的数据逻辑 分库、分表，降低单库、单表的数据量 数据库读写分离，两个数据库，一个作为写，一个作为读 不用外键，不用连表查询 五：高可用 5.1 备份 5.1.1 逻辑备份 使用 mysql 自带的 mysqldump 工具进行备份。备份成 sql 文件形式\n优点：最大好处是能够与正在运行的 mysql 自动协同工作，在运行期间可以确保备份是当时的点，它会自动将对应操作的表锁定，不允许其他用户修改(只能访问)。可能会阻止修改操作。sql 文件通用方便移植\n缺点：备份的速度比较慢。如果是数据量很多的时候。就很耗时间。如果数据库服务器处在提供给用户服务状态，在这段长时间操作过程中，意味着要锁定表(一般是读锁定，只能读不能写入数据)。那么服务就会影响的\n5.1.2 物理备份 直接拷贝 mysql 的数据目录，直接拷贝只适用于 myisam 类型的表。这种类型的表是与机器独立的。但实际情况是，你设计数据库的时候不可能全部使用 myisam 类型表。你也不可能因为 myisam 类型表与机器独立，方便移植，于是就选择这种表，这并不是选择它的理由\n缺点：你不能去操作正在运行的 mysql 服务器(在拷贝的过程中有用户通过应用程序访问更新数据，这样就无法备份当时的数据)可能无法移植到其他机器上去。\n5.1.3 双机热备份 mysql 数据库没有增量备份的机制。当数据量太大的时候备份是一个很大的问题。还好 mysql 数据库提供了一种主从备份的机制(也就是双机热备)\n优点：适合数据量大的时候。大的互联网公司对于 mysql 数据备份，都是采用热机备份。搭建多台数据库服务器，进行主从复制\n5.2 主从复制 一个主动可调用的，一个被动可调整\nMysql如何减少主从延迟？\n架构师必备：MySQL主从延迟解决办法 如果延迟比较大，就先确认以下几个因素：\n从库硬件比主库差，导致复制延迟 主从复制单线程，如果主库写并发太大，来不及传送到从库就会导致延迟。更高版本的mysql可以支持 多线程复制 慢SQL语句过多 网络延迟 master负载：主库读写压力大，导致复制延迟，架构的前端要加buffer及缓存层 slave负载：一般的做法是，使用多台slave来分摊读请求，再从这些slave中取一台专用的服务器只作 为备份用，不进行其他任何操作 主从同步延迟解决方案\n减少slave同步延时的方案就是在架构上做优化，尽量让主库的DDL快速执行 主库是写，对数据安全性较高，比如sync_binlog=1，innodb_flush_log_at_trx_commit = 1 之类的设置，而slave则不需要这么高的数据安全，完全可以讲sync_binlog设置为0或者关闭binlog innodb_flushlog也可以设置为0来提高sql的执行效率 使用比主库更好的硬件设备作为slave 六：相关阅读 MyISAM 与 InnoDB 区别 博客文章 MySQL 在大数据、高并发场景下的 SQL 语句优化和最佳实践 对 mysql 的高并发优化配置的一些思考 主从复制原理 使用Python3编写脚本一键备份MySQL数据库 ","wordCount":"264","inLanguage":"en","datePublished":"2021-10-01T15:40:18Z","dateModified":"2021-10-01T15:40:18Z","mainEntityOfPage":{"@type":"WebPage","@id":"http://120.79.76.172:8381/post/mysql%E5%9F%BA%E7%A1%80/"},"publisher":{"@type":"Organization","name":"haoyu blog","logo":{"@type":"ImageObject","url":"http://120.79.76.172:8381/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://120.79.76.172:8381 accesskey=h title="haoyu blog (Alt + H)"><img src=http://120.79.76.172:8381/apple-touch-icon.png alt aria-label=logo height=35>haoyu blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://120.79.76.172:8381/archives/ title=时间轴><span>时间轴</span></a></li><li><a href=http://120.79.76.172:8381/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://120.79.76.172:8381>Home</a>&nbsp;»&nbsp;<a href=http://120.79.76.172:8381/post/>Posts</a></div><h1 class=post-title>mysql基础</h1><div class=post-meta><span title='2021-10-01 15:40:18 +0000 UTC'>October 1, 2021</span>&nbsp;·&nbsp;264 words</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#一数据库>一：数据库</a><ul><li><a href=#11-mysql-引擎>1.1 MySQL 引擎</a></li><li><a href=#12-mysql-80新特性>1.2 MySQL 8.0新特性</a></li></ul></li><li><a href=#二主键与外键>二：主键与外键</a><ul><li><a href=#21-主键>2.1 主键</a></li><li><a href=#22-外键>2.2 外键</a></li></ul></li><li><a href=#三高级>三：高级</a><ul><li><a href=#31-视图>3.1 视图</a></li><li><a href=#32-存储过程>3.2 存储过程</a></li><li><a href=#33-游标>3.3 游标</a></li><li><a href=#34-触发器>3.4 触发器</a></li></ul></li><li><a href=#四其他>四：其他</a><ul><li><a href=#41-自增>4.1 自增</a></li><li><a href=#42-内连表左连表右连表>4.2 内连表、左连表、右连表</a></li><li><a href=#43-drop-delete-与-truncate>4.3 drop, delete 与 truncate</a></li><li><a href=#44-sql-语句安全性>4.4 sql 语句安全性</a></li><li><a href=#45-如何应对数据的高并发大量的数据计算>4.5 如何应对数据的高并发，大量的数据计算</a></li></ul></li><li><a href=#五高可用>五：高可用</a><ul><li><a href=#51-备份>5.1 备份</a></li><li><a href=#511-逻辑备份>5.1.1 逻辑备份</a></li><li><a href=#512-物理备份>5.1.2 物理备份</a></li><li><a href=#513-双机热备份>5.1.3 双机热备份</a></li><li><a href=#52-主从复制>5.2 主从复制</a></li></ul></li><li><a href=#六相关阅读>六：相关阅读</a></li></ul></nav></div></details></div><div class=post-content><h1 id=基础>基础<a hidden class=anchor aria-hidden=true href=#基础>#</a></h1><p>[TOC]</p><h2 id=一数据库>一：数据库<a hidden class=anchor aria-hidden=true href=#一数据库>#</a></h2><h3 id=11-mysql-引擎>1.1 MySQL 引擎<a hidden class=anchor aria-hidden=true href=#11-mysql-引擎>#</a></h3><p>存储引擎指表的类型，决定了表在计算机中的存储方式。MySQL 默认存储引擎为 InnoDB，支持事务、原子操作、回滚等等。常见的存储引擎 InnoDB 和 MyISAM。如果系统读多写少，并发不高，对原子性要求低，选择 MyISAM；如果系统读少写多，尤其是并发写入高的时候，首选 InnoDB</p><table><thead><tr><th style=text-align:center>引擎</th><th style=text-align:center>InnoDB</th><th style=text-align:center>MyISAM</th></tr></thead><tbody><tr><td style=text-align:center>事务</td><td style=text-align:center>支持</td><td style=text-align:center>不支持</td></tr><tr><td style=text-align:center>锁</td><td style=text-align:center>支持到行级锁</td><td style=text-align:center>只支持表级锁</td></tr><tr><td style=text-align:center>MVCC</td><td style=text-align:center>支持</td><td style=text-align:center>不支持</td></tr><tr><td style=text-align:center>外键</td><td style=text-align:center>支持</td><td style=text-align:center>不支持</td></tr><tr><td style=text-align:center>全文索引</td><td style=text-align:center>不支持</td><td style=text-align:center>支持</td></tr></tbody></table><h3 id=12-mysql-80新特性>1.2 MySQL 8.0新特性<a hidden class=anchor aria-hidden=true href=#12-mysql-80新特性>#</a></h3><ul><li>窗口函数：可以对一组查询行执行聚合，为每行生成一个结果</li><li>递归 CTE：支持用户在不使用游标的情况下，执行引用其自身名称的子查询</li><li>默认字符集支持从 <code>Latin1</code> 转变为 <code>utf8mb4</code>，其中，<code>utf8mb4</code> 支持每个字符最多使用四个字节</li><li>隐藏索引：允许从查询优化器中排除索引</li><li>改进对 JSON 的支持，增加了 JSON_EXTRACT 函数，可以根据路径查询参数从 json 字段中提取数据</li><li>提供了灵活的角色支持，包括创建、删除和授予角色功能</li></ul><h2 id=二主键与外键>二：主键与外键<a hidden class=anchor aria-hidden=true href=#二主键与外键>#</a></h2><h3 id=21-主键>2.1 主键<a hidden class=anchor aria-hidden=true href=#21-主键>#</a></h3><ul><li>确定一条记录的唯一标识</li><li>可以被外键有效引用</li><li>一张表只能有一个主键，其值不能重复，不能为空</li><li>如果主键为多列，则其组合必须唯一</li></ul><p><strong>主键设计原则:</strong></p><ul><li>主键应当是对用户没有意义的</li><li>一般将自增列设置为主键</li><li>永远不要更新主键</li><li>主键应该为单列，以提高连接和筛选操作的效率</li><li>主键不应包含动态变化的数据，如时间戳、创建时间列、修改时间列等</li></ul><h3 id=22-外键>2.2 外键<a hidden class=anchor aria-hidden=true href=#22-外键>#</a></h3><p>如果一张表中有一个非主键的字段指向了别一张表中的主键，就将该字段叫做<strong>外键</strong></p><ul><li>表的外键是另一表的主键</li><li>一张表可以有多个外键，其值可以重复，可以为空</li><li>外键名字不能重复</li><li>外键的列类型必须与父表的主键类型应一致</li></ul><p><strong>外键设计原则:</strong></p><ul><li>外键用来和其他表建立联系（约束），实现表与表之间数据的一致性和更新</li><li>创建外键时自动将外键所在列设置索引列</li><li>表储存引擎必须是 innodb，否则创建的外键无约束效果</li><li>将已经存在数据的字段设为外键，必须保证字段中的数据与父表的主键数据对应</li><li>子表(外键所在的表)在进行写操作的时候，如果外键字段在父表中找不到对应的匹配，操作失败</li><li>父表的主键字段进行删和改时，如果对应的主键在子表中被引用，操作失败</li><li>创建外键时可选择不同的约束模式</li></ul><p><strong>外键的性能问题:</strong></p><ul><li>数据库要维护外键的内部管理</li><li>对外键字段进行增删改查会消耗资源去检查</li></ul><h2 id=三高级>三：高级<a hidden class=anchor aria-hidden=true href=#三高级>#</a></h2><h3 id=31-视图>3.1 视图<a hidden class=anchor aria-hidden=true href=#31-视图>#</a></h3><ul><li>视图是虚拟（临时）的表，与包含数据的表不一样，只能用做查询</li><li>视图只在执行时才动态检索数据</li><li>视图可以简化复杂的 sql 操作，隐藏具体的细节，保护数据</li><li>视图创建后，可以使用与表相同的方式利使用</li><li>视图不能被索引，也不能有关联的触发器或默认值</li></ul><p><strong>视图和表的区别：</strong></p><ul><li>视图是已经编译好的 sql 语句，是基于 sql 语句的结果集的可视化的表，而表不是</li><li>视图是窗口，表是内容</li><li>视图没有实际的物理记录，而表有</li><li>视图是虚表，表是实表</li><li>视图的建立和删除只影响视图本身，不影响对应的表</li></ul><h3 id=32-存储过程>3.2 存储过程<a hidden class=anchor aria-hidden=true href=#32-存储过程>#</a></h3><p>存储过程是一个预编译的SQL语句，只需创建一次，以后在该程序中就可以调用多次。使用存储过程比单纯 SQL 语句执行要快</p><p><strong>优点：</strong></p><ul><li>存储过程是预编译过的，执行效率高</li><li>存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯</li><li>安全性高，执行存储过程需要有一定权限的用户</li><li>存储过程可以重复使用，可减少数据库开发人员的工作量</li></ul><p>缺点：移植性差</p><h3 id=33-游标>3.3 游标<a hidden class=anchor aria-hidden=true href=#33-游标>#</a></h3><p>游标是通过 select 查询出来的结果集，通过游标可以从结果集中获得指定行（第一行、下一行、前10行）</p><p>游标一般用于交互式应用，需要逐条处理数据的时候，游标显得十分重要</p><h3 id=34-触发器>3.4 触发器<a hidden class=anchor aria-hidden=true href=#34-触发器>#</a></h3><p>触发器是一中特殊的存储过程，主要是通过事件来触发而被执行的</p><h2 id=四其他>四：其他<a hidden class=anchor aria-hidden=true href=#四其他>#</a></h2><h3 id=41-自增>4.1 自增<a hidden class=anchor aria-hidden=true href=#41-自增>#</a></h3><p>在每个行添加到表中时，MySQL 可以自动地为每个行分配下一个可用编号</p><ul><li>自增列在插入数据时默认自动添加</li><li>表中只能有一个自增列</li><li>自增列类型为数字</li><li>自增列必须是索引</li></ul><h3 id=42-内连表左连表右连表>4.2 内连表、左连表、右连表<a hidden class=anchor aria-hidden=true href=#42-内连表左连表右连表>#</a></h3><ul><li>内连接：两个表都存在匹配时，才会返回匹配行。第一个表中的每一行与第二个表中的每一行数据配对</li><li>左连接：是根据某个条件以及左边的表连接数据，右边的表没有数据的话则为 null</li><li>右连接：根据某个条件以及右边的表连接数据，左边的表没有数据的话则为 null</li></ul><h3 id=43-drop-delete-与-truncate>4.3 drop, delete 与 truncate<a hidden class=anchor aria-hidden=true href=#43-drop-delete-与-truncate>#</a></h3><ol><li>drop 直接删掉表，并将表所占用的空间全释放掉</li><li>truncate 删除表中数据，再插入时自增长 id 又从 1 开始。truncate 可以理解为 drop + create。当表被 truncate 后，表和索引所占用的空间会恢复到初始大小</li><li>delete 删除表中数据，可以加 where 子句。delete 命令只是把记录的位置标记为了“可复用”，但磁盘文件的大小是不会变的。即通过 delete 命令是不能回收表空间的</li></ol><h3 id=44-sql-语句安全性>4.4 sql 语句安全性<a hidden class=anchor aria-hidden=true href=#44-sql-语句安全性>#</a></h3><ul><li>防止 sql 注入，对特殊字符进行转义，过滤或者使用预编译的 sql 语句绑定变量</li><li>最小权限原则，特别是不要用 root 账户，为不同的类型的动作或者组建使用不同的账户</li><li>当 sql 运行出错时，不要把数据库返回的错误信息全部显示给用户，以防止泄漏服务器和数据库相关信息</li></ul><h3 id=45-如何应对数据的高并发大量的数据计算>4.5 如何应对数据的高并发，大量的数据计算<a hidden class=anchor aria-hidden=true href=#45-如何应对数据的高并发大量的数据计算>#</a></h3><ul><li>合理设计表结构、索引</li><li>使用存储过程来处理复杂的数据逻辑</li><li>分库、分表，降低单库、单表的数据量</li><li>数据库读写分离，两个数据库，一个作为写，一个作为读</li><li>不用外键，不用连表查询</li></ul><h2 id=五高可用>五：高可用<a hidden class=anchor aria-hidden=true href=#五高可用>#</a></h2><h3 id=51-备份>5.1 备份<a hidden class=anchor aria-hidden=true href=#51-备份>#</a></h3><h3 id=511-逻辑备份>5.1.1 逻辑备份<a hidden class=anchor aria-hidden=true href=#511-逻辑备份>#</a></h3><p>使用 mysql 自带的 mysqldump 工具进行备份。备份成 sql 文件形式</p><p><strong>优点</strong>：最大好处是能够与正在运行的 mysql 自动协同工作，在运行期间可以确保备份是当时的点，它会自动将对应操作的表锁定，不允许其他用户修改(只能访问)。可能会阻止修改操作。sql 文件通用方便移植</p><p><strong>缺点</strong>：备份的速度比较慢。如果是数据量很多的时候。就很耗时间。如果数据库服务器处在提供给用户服务状态，在这段长时间操作过程中，意味着要锁定表(一般是读锁定，只能读不能写入数据)。那么服务就会影响的</p><h3 id=512-物理备份>5.1.2 物理备份<a hidden class=anchor aria-hidden=true href=#512-物理备份>#</a></h3><p>直接拷贝 mysql 的数据目录，直接拷贝只适用于 myisam 类型的表。这种类型的表是与机器独立的。但实际情况是，你设计数据库的时候不可能全部使用 myisam 类型表。你也不可能因为 myisam 类型表与机器独立，方便移植，于是就选择这种表，这并不是选择它的理由</p><p><strong>缺点</strong>：你不能去操作正在运行的 mysql 服务器(在拷贝的过程中有用户通过应用程序访问更新数据，这样就无法备份当时的数据)可能无法移植到其他机器上去。</p><h3 id=513-双机热备份>5.1.3 双机热备份<a hidden class=anchor aria-hidden=true href=#513-双机热备份>#</a></h3><p>mysql 数据库没有增量备份的机制。当数据量太大的时候备份是一个很大的问题。还好 mysql 数据库提供了一种主从备份的机制(也就是双机热备)</p><p><strong>优点</strong>：适合数据量大的时候。大的互联网公司对于 mysql 数据备份，都是采用热机备份。搭建多台数据库服务器，进行主从复制</p><h3 id=52-主从复制>5.2 主从复制<a hidden class=anchor aria-hidden=true href=#52-主从复制>#</a></h3><p>一个主动可调用的，一个被动可调整</p><p>Mysql如何减少主从延迟？</p><ul><li><a href=https://segmentfault.com/a/1190000040821444>架构师必备：MySQL主从延迟解决办法</a></li></ul><p>如果延迟比较大，就先确认以下几个因素：</p><ul><li>从库硬件比主库差，导致复制延迟</li><li>主从复制单线程，如果主库写并发太大，来不及传送到从库就会导致延迟。更高版本的mysql可以支持 多线程复制</li><li>慢SQL语句过多</li><li>网络延迟</li><li>master负载：主库读写压力大，导致复制延迟，架构的前端要加buffer及缓存层</li><li>slave负载：一般的做法是，使用多台slave来分摊读请求，再从这些slave中取一台专用的服务器只作 为备份用，不进行其他任何操作</li></ul><p>主从同步延迟解决方案</p><ul><li>减少slave同步延时的方案就是在架构上做优化，尽量让主库的DDL快速执行</li><li>主库是写，对数据安全性较高，比如sync_binlog=1，innodb_flush_log_at_trx_commit = 1 之类的设置，而slave则不需要这么高的数据安全，完全可以讲sync_binlog设置为0或者关闭binlog innodb_flushlog也可以设置为0来提高sql的执行效率</li><li>使用比主库更好的硬件设备作为slave</li></ul><h2 id=六相关阅读>六：相关阅读<a hidden class=anchor aria-hidden=true href=#六相关阅读>#</a></h2><ul><li><a href=https://segmentfault.com/a/1190000008227211>MyISAM 与 InnoDB 区别</a></li><li><a href=http://www.cnblogs.com/wupeiqi/articles/5713315.html>博客文章</a></li><li><a href=https://segmentfault.com/a/1190000007311574>MySQL 在大数据、高并发场景下的 SQL 语句优化和最佳实践</a></li><li><a href=http://blog.51cto.com/xiaozhagn/2073900>对 mysql 的高并发优化配置的一些思考</a></li><li><a href=https://jaminzhang.github.io/mysql/MySQL-Master-Slave-Replication-Principle/>主从复制原理</a></li><li><a href=https://www.aaronjny.com/articles/2019/11/19/1574145044800.html>使用Python3编写脚本一键备份MySQL数据库</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://120.79.76.172:8381/tags/mysql/>mysql</a></li></ul><nav class=paginav><a class=prev href=http://120.79.76.172:8381/post/%E5%AE%89%E5%85%A8/><span class=title>« Prev</span><br><span>安全</span></a>
<a class=next href=http://120.79.76.172:8381/post/python%E5%88%97%E8%A1%A8%E4%B8%8E%E5%85%83%E7%BB%84/><span class=title>Next »</span><br><span>python列表与元组</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=http://120.79.76.172:8381>haoyu blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>